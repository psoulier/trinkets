#include "printdbg.hpp"

void console_putc(char c);

/*
 * If your MCU doesn't have a divide instruction and you don't want to include
 * a full library to support division, put an divide-by-10 implmenetation here.
 */
template <typename T>
T DIV10(T x)
{
    return x / 10;
}

constexpr uintptr_t logn(const uintptr_t x, const uintptr_t b)
{
    return (x < b) ? 1 : logn(x/b, b) + 1;
}

static const char       *ERRMSG = "  -- dbgprint: Invalid print format.\n";
static const uintptr_t  MAXDIGITS = logn(static_cast<uintptr_t>(-1), 10) + 1;
static const char       BIN2CHR[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
                                     'a', 'b', 'c', 'd', 'e', 'f'};
static int dbgprint_paddigits(const char **fmt)
{
    int pad = 0,
        n;

    /*
     * We're only dealing with ASCII, so the format character less the ASCII
     * digit '0' will give us a binary decimal number,
     */
    n = **fmt - '0';
    while (n >= 0 && n < 10) {
        pad *= 10;
        pad += n;
        *fmt += 1;
        n = **fmt - '0';
    }

    return pad;
}

/*
 * Prints unsigned integer.
 */
static void dbgprint_dec(int pad, char c, _dbgprint_arg a, bool sign)
{
    char        dec[MAXDIGITS];
    uintptr_t   i = 0;

    /*
     * Handled signed integers.  When 'sign' is true, the format qualifier
     * was a 'd'.
     */
    if (sign && a.ival < 0) {
        a.ival *= -1;
    }
    else {
        sign = false;
    }

    /*
     * Convert int to text.  This may be an issue for MCUs that don't have a
     * divide instruction.
     */
    do {
        dec[i] = BIN2CHR[a.val % 10];
        a.val = DIV10(a.val);
        i += 1;
    } while (a.val);

    // Minus sign for negative numbers...
    if (sign) {
        dec[i] = '-';
        i++;
    }

    // Padding...
    for (; i < pad; i++) {
        dec[i] = c;
    }

    /*
     * Print in reverse order so it reads correctly.
     */
    while (i > 0) {
        i -= 1;
        console_putc(dec[i]);
    }
}


static void dbgprint_hex(int pad, char c, _dbgprint_arg a)
{
    char        hex[sizeof(uintptr_t)*2];   // Hex string representation of integer.
    int         i = 0;

    /*
     * Convert integer to hex string; 'digits' will point to the next unfilled
     * element in the 'hex' array.
     */
    do {
        hex[i] = BIN2CHR[a.val & 0xf];
        a.val >>= 4;
        i += 1;
    } while (a.val);

    for (; i < pad; i++) {
        hex[i] = c;
    }

    /*
     * The 'hex' array should have our hex string representation of the integer
     * in reverse order suitable for printing to a serial output.
     */
    while (i > 0) {
        i -= 1;
        console_putc(hex[i]);
    }
}

/*
 * Prints formatted string.  Parameters generated by like-named template
 * function.
 */
void _dbgprint(const char *fmt, _dbgprint_arg *argarr, uintptr_t argc)
{
    uintptr_t       argi = 0;

    while (*fmt != '\0') {
        if (*fmt != '%') {
            console_putc(*fmt);
            fmt += 1;
        }
        else if (argi >= argc) {
            /*
             * More format specifiers than arguments.  Switch to error string.
             */
            fmt = ERRMSG;
        }
        else {
            int     n = 0;
            char    c = ' ';

            fmt++;  // Move past '%'.

            /*
             * Check if padding should filled with 0's.
             */
            if (*fmt == '0') {
                c = '0';
                fmt++;
            }

            /*
             * Check if padding was requested and compute the number of padding
             * characters if necessary.
             */
            n = *fmt - '0';
            if (n >= 0 && n < 10) {
                n = dbgprint_paddigits(&fmt);
            }
            else {
                n = 0;
            }

            /*
             * Ignore the 'l' formatting qualifier if it's present.
             */
            if (*fmt == 'l') {
                fmt++;
            }

            switch (*fmt) {
                case 'd':
                    dbgprint_dec(n, c, argarr[argi], true);
                    break ;
                case 'u':
                    dbgprint_dec(n, c, argarr[argi], false);
                    break ;
                case 'x':
                    dbgprint_hex(n, c, argarr[argi]);
                    break ;
                case 'p':
                    console_putc('0');
                    console_putc('x');
                    dbgprint_hex(n, c, argarr[argi]);
                    break ;
                case '%':
                    console_putc('%');
                    break ;
                case 'c':
                    console_putc(static_cast<char>(argarr[argi].val));
                    break ;
                case 's':
                    while (*argarr[argi].str != '\0') {
                        console_putc(*argarr[argi].str++);
                    }
                    break ;
                case '\0': return ;
                default:
                    fmt = ERRMSG;
                    break ;
            }

            fmt++;
            argi++;
        }
    }
}

#ifdef __TEST__

#include <stdio.h>
#include <assert.h>
#include <string>
std::string printstr = "";
void console_putc(char c)
{
    printstr += c;
}

#define TEST(...) \
    printstr = ""; \
    sprintf(s, __VA_ARGS__); \
    dbgprint(__VA_ARGS__); \
    if (printstr != s) { \
        printf("FAILED: expected: \"%s\" actual: \"%s\"\n", s, printstr.c_str()); \
    } \

int main()
{
    uintptr_t   bigint = static_cast<uintptr_t>(-1);
    char        s[128];

    TEST("Hello World!\n");
    TEST("signed int=%d", -13);
    TEST("unsigned int=%lu", bigint);
    TEST("hex=%x", 0x1234);
    TEST("hex=%06x\n", 0x5678);
    TEST("Hello %s\n", "World!");
    TEST("Boo%c", '!');
    TEST("One %d two %4x three %s GO!", 1, 0x23, "Set, ");

    void    *p = nullptr;
    TEST("pointer=%p", p);
    p = &s;
    TEST("pointer=%p", p);

    printstr = "";
    dbgprint("Bad dog! %o6x\n", 0);
    assert(printstr.find(ERRMSG) != std::string::npos);
}

#endif

